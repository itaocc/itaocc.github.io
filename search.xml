<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[开始使用Next[转发]]]></title>
    <url>%2F2018%2F11%2F08%2Fmine%2F</url>
    <content type="text"><![CDATA[Hexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。 http://theme-next.iissnan.com/getting-started.htmlhttps://www.cnblogs.com/debugzer0/articles/5461804.html四种风格https://blog.csdn.net/acm_th/article/details/79974513]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[迭代器和生成器]]></title>
    <url>%2F2018%2F01%2F10%2F2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器和生成器迭代: 访问集合元素的一种方式. 通常把使用for循环取数的过程称为遍历, 也叫迭代. 可迭代对象（Iterable）: 把可以通过for…in…这类语句迭代读取⼀条数据供我们使⽤的对象称之为可迭代对象. 很多容器都是可迭代对象(iterable), 并不是所有容器都是可以迭代的;但凡可以返回一个迭代器的对象都是可迭代对象; 容器: 这个称呼在其他博客上看到的, 了解下; 一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not in关键字判断元素是否包含在容器中 . 常见的str, list, set, dict都是容器 可以使用 isinstance() 判断一个对象是否是 Iterable 对象 12345678from collections import Iterableprint(isinstance([], Iterable)) # 判断列表print(isinstance((), Iterable)) # 判断元组print(isinstance(&#123;&#125;, Iterable)) # 判断字典print(isinstance("", Iterable)) # 判断字符串print(isinstance(100, Iterable)) # 判断整数print(isinstance(False, Iterable)) # 判断boolean 1.迭代器iterator迭代器: 任何实现了__iter__和__next__()（python2中实现next()）方法的对象都是迭代器; __iter__返回迭代器自身，__next__返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常 在遍历过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为迭代器(Iterator)。可迭代对象的本质就是提供一个这样的中间“人”即迭代器帮助我们对其进行迭代遍历使用。 可迭代对象的本质就是提供一个这样的中间“人”即迭代器帮助我们对其进行迭代遍历使用 可迭代对象是一个具备了__iter__方法的对象，通过__iter__方法获取可迭代对象的迭代器 迭代器本质上是一个产生值的工厂，每次向迭代器请求下一个值，迭代器都会进行计算出相应的值并返回。 可以通过iter()函数获取这些可迭代对象的迭代器, 然后可以对获取到的迭代器不断使用next()函数来获取下一条数据。 12345678li = [11, 22, 33, 44, 55]# 通过iter() 取得可迭代对象的迭代器iterator = iter(li)# 通过next()函数取得iterator迭代器指向的下一个值print(next(iterator))print(next(iterator)) 1.1 __iter__和__next__迭代器首先是一个可迭代对象, 可迭代对象必须实现__iter__方法 迭代器同时要能够返回可迭代对象的下一个值，所以当调用next()函数的时候，需要能够返回值，所以必须定义next方法； 1.2 for循环for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束。 1.3 代码实例:12345678910111213141516171819202122232425262728293031323334353637import collectionsclass MyClassmate(object): def __init__(self): self.names = [] # 声明一个列表 self.current = 0 # 记录迭代器迭代的位置， 默认是0 ，即从起始位置开始 def add(self, name): self.names.append(name) def __iter__(self): """通过该方法取得迭代器对象""" return self def __next__(self): """取得下一个迭代的值""" if self.current &lt; len(self.names): name = self.names[self.current] self.current += 1 return name else: raise StopIteration# 创建MyClassmate实例my_classmate = MyClassmate()my_classmate.add("小王")my_classmate.add("小李")my_classmate.add("小张")# 测试MyList是不是可迭代对象print(isinstance(my_classmate, collections.Iterable))# 遍历数据for name in my_classmate: print(name) 1.4 应用场景斐波拉契序列 12345678910111213141516171819202122232425262728293031class FibIterator(object): """斐波那契数列迭代器""" def __init__(self, n): """初始化属性""" self.n = n # 记录生成fibonacci的数列的个数 self.current_index = 0 # 记录当前遍历的下标 # 记录fibonacci数列前面的两个值 self.num1 = 0 self.num2 = 1 def __next__(self): """被next()函数调用来获取下一个数""" if self.current_index &lt; self.n: num = self.num1 self.num1, self.num2 = self.num2, self.num1 + self.num2 self.current_index += 1 return num else: raise StopIteration def __iter__(self): """迭代器的__iter__返回自身即可""" return selfif __name__ == '__main__': fib = FibIterator(10) for num in fib: print(" ", num, end="") 运行结果: 0 1 1 2 3 5 8 13 21 34 2.生成器generator生成器: 可以理解为一个特殊的迭代器。调用这个函数就得到一个迭代器，生成器中的yield相当于一个断点，执行到此返回一个值后暂停，从而实现next取值。 任意生成器都是迭代器（反过来不成立） 任意生成器，都是一个可以延迟创建值的工厂 它不需要再像上面的类一样写__iter__()和__next__()方法了，只需要一个yiled关键字。 2.1 创建生成器方法2.1.1 把列表生成式的[] 改成()12345678# 参考列表生成式L=[x*2 for x in range(6)]print(L) # 输出结果:[0, 2, 4, 6, 8, 10]# 把[] 改为() :就是一个简单的列表生成器G=(x*2 for x in range(6))print(G) # 输出的是生成器对象: &lt;generator object &lt;genexpr&gt; at 0x7ff7f8bbd5c8&gt; 2.1.2 列表生成式用生成器实现斐波拉契序列 12345678def fib(): """斐波拉契函数""" prev, curr = 0, 1 while True: yield curr prev, curr = curr, curr + prevf = fib()print(list(islice(f,0, 10))) # 输出结果是[1, 1, 2, 3, 5, 8, 13, 21, 34, 55] fib就是一个普通的python函数，它特殊的地方在于函数体中没有return关键字，函数的返回值是一个生成器对象。当执行f=fib()返回的是一个生成器对象，此时函数体中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码。 另外一种写法: 12345678910111213141516171819def fib(n): curr_index = 0 num1, num2 = 0, 1 while curr_index &lt; n: """ 1. 假如函数中有yield，则不再是函数，而是生成器 2. yield 会产生一个断点 3. 假如yield后面紧接着一个数据，就会把数据返回， 作为next()函数或者for ...in...迭代出的下一个值 """ yield num1 num1, num2 = num2, num1 + num2 curr_index += 1 if __name__ = '__main__': G = fib(5) # # 假如函数中有yield，则不再是函数，而是一个生成器 # 生成器是一种特殊的迭代器 for num in G print("", num, end="") # 输出0 1 1 2 3 5 2.2 生成器总结 使用了yield关键字的函数不再是函数，而是生成器。（使用了yield的函数就是生成器） yield关键字有两点作用： 保存当前运行状态（断点），然后暂停执行，即将生成器（函数）挂起 将yield关键字后面表达式的值作为返回值返回，此时可以理解为起到了return的作用 可以使用next()函数让生成器从断点处继续执行，即唤醒生成器（函数） 2.3 使用send我们除了可以使用next()函数来唤醒生成器继续执行外，还可以使用send()函数来唤醒执行。使用send()函数的一个好处是可以在唤醒的同时向断点处传入一个附加数据。 执行到yield时，gen函数会暂停，返回i的值; temp接收下次obj.send(“haha”)发送过来的值，next(obj)等价obj.send(None) 123456789101112131415161718192021222324def gen(): i = 0 while i &lt; 5: temp = yield i print(temp) i += 1if __name__ == '__main__': obj = gen() # 取得生成器对象 # 使用next()唤醒生成器 print(next(obj)) print(next(obj)) # 使用send唤醒生成器 ，在唤醒的同时向断点处传入一个附加数据 print(obj.send("haha")) # 使用next()唤醒生成器 print(next(obj)) # 使用send唤醒生成器 ，在唤醒的同时向断点处传入一个附加数据 print(obj.send("python"))]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django]]></title>
    <url>%2F2018%2F01%2F08%2FDjango%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Django登录接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from rest_framework.response import Responsefrom rest_framework.views import APIViewimport randomfrom django_redis import get_redis_connectionfrom ls.models import Userfrom rest_framework import exceptionsimport uuidclass Hello(APIView): def get(self, request): # 生成图形验证码 image_code = random.randint(1000, 9999) # 保存到redis数据库 redis_cli = get_redis_connection("default") user_id = uuid.uuid1() redis_cli.set(user_id, image_code) print(user_id) print(image_code) return Response(&#123;"image_code": image_code, "user_id": user_id&#125;) def post(self, request): data = request.data mobile = data.get("mobile") user_name = data.get("name") user_id = data.get("user_id") image_code = data.get("image_code") print(user_id) # 判断手机号 new_mobile = User.objects.filter(mobile=mobile).count() if new_mobile &gt; 0: raise exceptions.ValidationError("手机号已存在") # 判断用户名是否存在 new_user_name = User.objects.filter(username=user_name).count() if new_user_name &gt; 0: raise exceptions.ValidationError("用户名已存在") # 判断图形验证码 redis_cli = get_redis_connection("default") try: new_image_code = redis_cli.get(user_id) print(new_image_code) except: raise exceptions.ValidationError("查询错误") if int(image_code) != int(new_image_code): raise exceptions.ValidationError("验证码错误") # 发送短信验证码 sms_code = random.randint(100000, 999999) user_sms_code = user_name + mobile redis_cli.set(user_sms_code, sms_code) print(sms_code) return Response(&#123;"message": "ok"&#125;)class Register(APIView): def post(self, request): data = request.data mobile = data.get("mobile") user_name = data.get("name") sms_code = data.get("sms_code") redis_cli = get_redis_connection("default") new_sms_code = redis_cli.get(user_name + mobile) if int(new_sms_code) != sms_code: raise exceptions.ValidationError("验证码错误") user = User() user.mobile = mobile user.username = user_name user.save() return Response(&#123;"message": "ok"&#125;)]]></content>
      <categories>
        <category>代码块</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask注册接口]]></title>
    <url>%2F2018%2F01%2F08%2F%E6%B3%A8%E5%86%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[flask中应用蓝图实现注册接口: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 注册提交# 注册也是前端点击，发送请求来后端，后端进行参数校验，将注册的数据保存到数据库，然后将保持登录的数据保存到redis中# 返回ok后，前端进行刷新页面@passport_bp.route("/register", methods=["POST"])def register(): """ 1 提取参数 2 参数验证 3 逻辑分析 4 返回数据 """ # 1 提取参数（提取表单提交的手机号，短信验证码与密码） json_data = request.json mobile = json_data.get("mobile", "") smscode = json_data.get("smscode", "") password = json_data.get("password", "") # 2 进行参数验证 if not all([mobile, smscode, password]): return jsonify(&#123;"errno": RET.PARAMERR, "errmsg": "参数不足"&#125;) if not re.match("1[3578][0-9]&#123;9&#125;", mobile): return jsonify(&#123;"errno": RET.PARAMERR, "errmsg": "手机号格式不对"&#125;) # 3 逻辑分析 # 3.1 最好在提交的时候再次判断用户手机号是否被注册，以防止用户在输入短信验证码后修改手机号 try: user = User.query.filter(User.mobile == mobile).first() except Exception as e: current_app.logger.error(e) return jsonify(&#123;"errno": RET.DATAERR, "errmsg": "查询用户手机号出错"&#125;) if user: return jsonify(&#123;"errno": RET.PARAMERR, "errmsg": "用户已经注册"&#125;) # 3.2 判断短信验证码是否正确 try: real_sms_code = redis_store.get("SMS_" + mobile) # print(redis_store.get("q")) except Exception as e: current_app.logger.error(e) return jsonify(&#123;"errno": RET.DBERR, "errmsg": "获取本地验证码失败"&#125;) print(real_sms_code) # 如果验证码为空 if not real_sms_code: return jsonify(&#123;"errno": RET.NODATA, "errmsg": "验证码过期"&#125;) if real_sms_code != smscode: return jsonify(&#123;"errno": RET.PARAMERR, "errmsg": "验证码错误"&#125;) # 获取到验证码后就把数据从redis数据库中删除 try: redis_store.delete("SMS_" + mobile) except Exception as e: current_app.logger.error(e) return jsonify(&#123;"errno": RET.DBERR, "errmsg": "redis删除获取到的验证码失败"&#125;) # 如果验证成功后就创建一个用户对象，添加到数据库中 user = User() user.mobile = mobile user.nick_name = mobile # 密码要进行加密处理（加密处理可以使用类中set和get的方法去实现） user.password = password # 添加到数据库中 try: db.session.add(user) db.session.commit() except Exception as e: current_app.logger.error(e) db.session.rollback() return jsonify(&#123;"errno": RET.DBERR, "errmsg": "存储数据库出错"&#125;) # 在redis中存储用户登录状态（此时还没写到注册模块，到时候就知道怎么为什么要这样写了） session["user_id"] = user.id session["nick_name"] = user.nick_name session["mobile"] = user.mobile print("ok") return jsonify(&#123;"errno": RET.OK, "errmsg": "ok"&#125;)]]></content>
      <categories>
        <category>代码块</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask代码框架]]></title>
    <url>%2F2018%2F01%2F08%2FFlask%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Flask代码框架文件及其目录 文件目录说明： Common：系统级配置 common/appconf.py 系统配置文件，用于不同环境可能修改的系统配置 common/applogger.py 日志模块代码 Conf：启动配置，和uwsgi有关联 Lib：公共库 Handler：业务代码 Handler/model：数据库表模块的定义 Common：公共函数、业务公共配置 Core_util：目前主要是异常处理，可以把common的和core_util合成一个 Common/mysql_session.py 数据库session（我们使用的是sqlachedemy） Common/op_Logs_interface.py 记录操作日志 Main.py 系统入口文件 123Handler/handlerfactory.py 所有接口的映射关系Handler/basehandler.py 接口基类，所有接口继承这个]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F01%2F08%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式Python中类是通过new来创建实例, 这个类从始至终只有一个实例, 用到__new__方法 代码1 123456789class A(object): _instance = None def __new__(cls, *args, **kwargs): if cls._instance is None: cls._instance = object.__new__(cls) return cls._instance else: return cls._instance 代码2: 12345678910111213class Singleton(object): def __new__(cls,*args,**kwargs): if not hasattr(cls,'_inst'): cls._inst=super(Singleton,cls).__new__(cls,*args,**kwargs) return cls._instif __name__=='__main__': class A(Singleton): def __init__(self,s): self.s=s a=A('apple') b=A('banana') print id(a),a.s print id(b),b.s]]></content>
      <categories>
        <category>代码块</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
</search>
